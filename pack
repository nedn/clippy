#!/bin/bash

# Script to combine content of text files in a directory recursively.
# Usage: ./combine_files.sh <directory> [pattern1] [pattern2] ...
# Example: ./combine_files.sh . '*.rs' '*.md'
# Example: ./combine_files.sh /path/to/project
# Example: ./combine_files.sh . | less
# Example: ./combine_files.sh . > combined.txt

# --- Configuration ---
OUTPUT_FILENAME="combined_content.txt" # Only used when outputting to terminal

# --- Function: Print usage ---
usage() {
  # Print usage message to stderr
  echo "Usage: $0 <directory> [file_pattern ...]" >&2
  echo "  <directory>: The directory to search recursively." >&2
  echo "  [file_pattern ...]: Optional shell patterns (e.g., '*.txt', 'main.*')." >&2
  echo "                      If no patterns are given, all non-binary, non-hidden files are included." >&2
  echo >&2
  echo "Output:" >&2
  echo "  If stdout is a terminal, combines content into a temporary file and prints its path." >&2
  echo "  If stdout is piped or redirected, prints the combined content directly to stdout." >&2
  echo "  Excludes binary files, hidden files (starting with '.'), and files within hidden directories." >&2
  exit 1
}

# --- Argument Validation ---
if [ "$#" -lt 1 ]; then
  echo "Error: Directory argument is missing." >&2
  usage
fi

TARGET_DIR="$1"
shift # Remove directory from arguments, patterns remain in $@

if [ ! -d "$TARGET_DIR" ]; then
  echo "Error: '$TARGET_DIR' is not a valid directory." >&2
  exit 1
fi

# --- Dependency Check ---
if ! command -v file &> /dev/null; then
    echo "Error: 'file' command not found. Please install it (usually part of 'file' package)." >&2
    exit 1
fi
if ! command -v mktemp &> /dev/null && [ -t 1 ]; then
    # mktemp is only strictly needed if we're writing to a temp file (terminal output)
    echo "Error: 'mktemp' command not found. Cannot create secure temporary directory for terminal output." >&2
    exit 1
fi


# --- Determine Output Method ---
OUTPUT_TARGET="" # Will be stdout or a temporary file path
TEMP_DIR=""      # Store temp dir path if created

# Check if stdout is connected to a terminal
if [ -t 1 ]; then
  # Outputting to terminal: Use a temporary file
  echo "Outputting to terminal. Creating temporary file..." >&2
  TEMP_DIR=$(mktemp -d)
  if [ ! -d "$TEMP_DIR" ]; then
      echo "Error: Could not create temporary directory." >&2
      exit 1
  fi
  OUTPUT_TARGET="$TEMP_DIR/$OUTPUT_FILENAME"
  # Ensure output file is empty/created before starting
  : > "$OUTPUT_TARGET" || { echo "Error: Could not create or clear output file: $OUTPUT_TARGET" >&2; rm -rf "$TEMP_DIR"; exit 1; }
else
  # Outputting to pipe/redirect: Use stdout
  # No file needs to be created here. Informational messages go to stderr.
  echo "Outputting directly to stdout (pipe or redirection detected)." >&2
  OUTPUT_TARGET="/dev/stdout" # Conceptually, we're writing to stdout
fi


# --- Normalize Target Directory Path ---
# Using realpath for robustness, fall back to simple cleaning if not available
if command -v realpath &> /dev/null; then
    TARGET_DIR_CLEAN=$(realpath "$TARGET_DIR")
else
    TARGET_DIR_CLEAN="${TARGET_DIR%/}" # Basic cleanup if realpath isn't there
fi


# --- Build find command arguments ---
find_args=("$TARGET_DIR_CLEAN")

# --- Pruning rules FIRST ---
# Prune any directory starting with '.' (e.g., .git, .cache, .vscode)
# Using -path '*/.*' ensures we match hidden dirs at any depth relative to start
# Using -name '.*' with -prune would only prune hidden dirs directly under TARGET_DIR_CLEAN
find_args+=( \( -name '.?*' -type d \) -prune ) # Match hidden dirs, prune them. Using .?* avoids matching '.' itself
find_args+=( -o ) # OR, proceed with the checks below

# --- Selection Rules ---
# Group the selection criteria
find_args+=( \( )

# Rule 1: Must NOT be a hidden file (basename starts with '.')
# We check this again here for files not inside pruned directories
find_args+=( -not -name '.?*' )

# Rule 2: Apply user-provided patterns if any
if [ "$#" -gt 0 ]; then
    find_args+=( -a \( ) # AND ( start pattern group
    first_pattern=true
    for pattern in "$@"; do
        if [ "$first_pattern" = false ]; then
            find_args+=( -o ) # OR between patterns
        fi
        find_args+=( -name "$pattern" )
        first_pattern=false
    done
    find_args+=( \) ) # end pattern group )
fi

# Rule 3: Must be a regular file
find_args+=( -a -type f ) # AND must be a file

# End the selection criteria group
find_args+=( \) )

# Action: Print the found filenames null-terminated
find_args+=( -print0 )

# --- Inform User (Redirected to stderr) ---
echo "Searching in: '$TARGET_DIR_CLEAN'" >&2
if [ "$#" -gt 0 ]; then
    echo "Matching patterns: $@" >&2
else
    echo "Matching all non-binary, non-hidden files (no specific patterns given)." >&2
fi
echo "Ignoring hidden files (starting with '.') and contents of hidden directories." >&2
echo "Ignoring binary files." >&2
if [ -n "$TEMP_DIR" ]; then # Only show temp file path if we created one
    echo "Temporary file will be: $OUTPUT_TARGET" >&2
fi
echo "Processing..." >&2

# --- Process Files ---
processed_count=0
skipped_binary_count=0
skipped_hidden_count=0 # Keep track for info, although find should exclude them

# Define where to send the combined content based on the earlier check
# If OUTPUT_TARGET is /dev/stdout, commands write directly to stdout.
# If OUTPUT_TARGET is a file path, commands append (>>) to that file.
output_command() {
    if [ "$OUTPUT_TARGET" = "/dev/stdout" ]; then
        cat # Read from stdin (pipe), write to stdout
    else
        # Use tee to write to file *and* potentially show progress/debug on stderr if needed
        # For now, just append silently. Use `tee -a "$OUTPUT_TARGET"` to also see output.
        cat >> "$OUTPUT_TARGET" # Read from stdin (pipe), append to file
    fi
}

# Use process substitution to feed find results into the loop
while IFS= read -r -d $'\0' file; do
    # Basic check for hidden files/paths - find should handle this, but as a safeguard/debug
    if [[ "$file" == *'/.?*'* || "$(basename "$file")" == .?* ]]; then
       # echo "DEBUG: Skipping hidden file/path that slipped through find: $file" >&2
       ((skipped_hidden_count++))
       continue
    fi

    mime_type=$(file --mime-type -b "$file")

    # Skip non-text files (including true binary files, directories, symlinks etc. caught here)
    # Allow empty files as they are technically text.
    if [[ ! "$mime_type" =~ ^text/.* ]] && [[ "$mime_type" != "inode/x-empty" ]]; then
        # echo "  Skipping non-text file: $file (MIME: $mime_type)" >&2
        ((skipped_binary_count++))
        continue
    fi

    # Make the path relative to the original TARGET_DIR for clearer output headers
    # Handle cases where TARGET_DIR might be '.' or have trailing slashes
    relative_path="${file#"$TARGET_DIR_CLEAN"/}"
    # If TARGET_DIR_CLEAN was '/', the above might leave a leading /
    relative_path="${relative_path#./}" # Clean up leading ./ if TARGET_DIR was .

    # Add header, content, and blank line, piping through output_command
    {
        echo ">>>> File: $relative_path" # Added "File:" for clarity
        cat "$file"
    } | output_command

    ((processed_count++))

done < <(find "${find_args[@]}")

# --- Completion Message (Redirected to stderr) ---
echo "Done." >&2
echo "Processed $processed_count file(s)." >&2
if [ "$skipped_binary_count" -gt 0 ]; then
    echo "Skipped $skipped_binary_count non-text file(s)." >&2
fi
# Include the count of hidden files skipped by the loop safeguard, though find should do the work
if [ "$skipped_hidden_count" -gt 0 ]; then
    echo "Skipped $skipped_hidden_count hidden file(s)/path(s) (safeguard check)." >&2
fi

# --- Final Output ---
if [ -n "$TEMP_DIR" ]; then
    # If we created a temp file (outputting to terminal),
    # print the path of the temp file to standard output.
    if [ "$processed_count" -gt 0 ]; then
      echo "Combined content is in: $OUTPUT_TARGET"
    else
      echo "No files processed. Temporary file is empty: $OUTPUT_TARGET" >&2
      # Optional: Remove empty temp dir/file if nothing was processed
      # rm -rf "$TEMP_DIR"
      # exit 0 # Or exit with a different code?
    fi
else
    # If we wrote to stdout directly, there's nothing more to print here.
    # The content has already been streamed.
    : # No-op
fi

# Clean up temp dir if created (optional, OS usually handles /tmp)
# trap 'rm -rf "$TEMP_DIR"' EXIT # Add this near the top if you want automatic cleanup

exit 0
